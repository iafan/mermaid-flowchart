{"version":3,"sources":["../src/index.ts","../src/parser.ts","../src/layout.ts","../src/renderer.ts"],"sourcesContent":["export {\n  parseFlowchart,\n  Direction,\n  FlowchartNode,\n  FlowchartEdge,\n  FlowchartSubgraph,\n  Flowchart,\n} from './parser'\n\nexport {\n  layoutFlowchart,\n  NodeLayout,\n  EdgeLayout,\n  SubgraphLayout,\n  FlowchartLayout,\n} from './layout'\n\nexport { renderFlowchartSvg } from './renderer'\n\nimport { parseFlowchart } from './parser'\nimport { layoutFlowchart } from './layout'\nimport { renderFlowchartSvg } from './renderer'\n\n/**\n * Parse Mermaid flowchart syntax and render as SVG.\n * @param source - Mermaid flowchart source string\n * @returns SVG string with CSS variable-based theming\n */\nexport function renderFlowchart(source: string): string {\n  const flowchart = parseFlowchart(source)\n  const layout = layoutFlowchart(flowchart)\n  return renderFlowchartSvg(flowchart, layout)\n}\n","export type Direction = 'TB' | 'BT' | 'LR' | 'RL'\n\nexport interface FlowchartNode {\n  id: string\n  label: string\n  shape: 'rect' | 'rounded' | 'diamond' | 'circle'\n}\n\nexport interface FlowchartEdge {\n  from: string\n  to: string\n  label?: string\n  style: 'solid' | 'dashed'\n}\n\nexport interface FlowchartSubgraph {\n  id: string\n  label: string\n  nodeIds: string[]\n  style?: Record<string, string>\n}\n\nexport interface Flowchart {\n  direction: Direction\n  nodes: Map<string, FlowchartNode>\n  edges: FlowchartEdge[]\n  subgraphs: FlowchartSubgraph[]\n}\n\nfunction parseNodeDefinition(text: string): { id: string; label: string; shape: FlowchartNode['shape'] } | null {\n  // Match: ID[label], ID(label), ID{label}, ID((label))\n  const patterns: Array<{ regex: RegExp; shape: FlowchartNode['shape'] }> = [\n    { regex: /^(\\w+)\\[\\[(.+)\\]\\]$/, shape: 'rect' },      // [[label]] - subroutine\n    { regex: /^(\\w+)\\[(.+)\\]$/, shape: 'rect' },          // [label] - rectangle\n    { regex: /^(\\w+)\\((.+)\\)$/, shape: 'rounded' },       // (label) - rounded\n    { regex: /^(\\w+)\\(\\((.+)\\)\\)$/, shape: 'circle' },    // ((label)) - circle\n    { regex: /^(\\w+)\\{(.+)\\}$/, shape: 'diamond' },       // {label} - diamond\n  ]\n\n  for (const { regex, shape } of patterns) {\n    const match = text.match(regex)\n    if (match) {\n      return { id: match[1], label: match[2], shape }\n    }\n  }\n\n  // Plain ID with no shape\n  const plainMatch = text.match(/^(\\w+)$/)\n  if (plainMatch) {\n    return { id: plainMatch[1], label: plainMatch[1], shape: 'rect' }\n  }\n\n  return null\n}\n\ninterface EdgeParseResult {\n  from: string\n  to: string\n  label?: string\n  style: 'solid' | 'dashed'\n  // Only set if the node has an actual definition (not just an ID reference)\n  fromNode?: FlowchartNode\n  toNode?: FlowchartNode\n}\n\nfunction parseEdge(line: string): EdgeParseResult | null {\n  // Patterns for edges with optional labels\n  // A --> B, A -->|label| B, A -.-> B, A -.->|label| B\n  const edgePatterns = [\n    /^(.+?)\\s*-->\\|\"?([^\"|]+)\"?\\|\\s*(.+)$/,    // -->|label|\n    /^(.+?)\\s*-\\.->\\|\"?([^\"|]+)\"?\\|\\s*(.+)$/,  // -.->|label|\n    /^(.+?)\\s*-->\\s*(.+)$/,                     // -->\n    /^(.+?)\\s*-\\.->\\s*(.+)$/,                   // -.->\n  ]\n\n  for (let i = 0; i < edgePatterns.length; i++) {\n    const match = line.match(edgePatterns[i])\n    if (match) {\n      const hasLabel = i < 2\n      const style: 'solid' | 'dashed' = i === 1 || i === 3 ? 'dashed' : 'solid'\n\n      let fromPart: string, toPart: string, label: string | undefined\n\n      if (hasLabel) {\n        fromPart = match[1].trim()\n        label = match[2].trim()\n        toPart = match[3].trim()\n      } else {\n        fromPart = match[1].trim()\n        toPart = match[2].trim()\n      }\n\n      // Parse the from and to parts - they might include node definitions\n      const fromNode = parseNodeDefinition(fromPart)\n      const toNode = parseNodeDefinition(toPart)\n\n      if (fromNode && toNode) {\n        const result: EdgeParseResult = {\n          from: fromNode.id,\n          to: toNode.id,\n          label,\n          style,\n        }\n\n        // Only include node definitions if they have actual labels (not just ID references)\n        if (fromNode.label !== fromNode.id) {\n          result.fromNode = fromNode\n        }\n        if (toNode.label !== toNode.id) {\n          result.toNode = toNode\n        }\n\n        return result\n      }\n    }\n  }\n\n  return null\n}\n\nfunction parseStyle(line: string): { id: string; styles: Record<string, string> } | null {\n  const match = line.match(/^style\\s+(\\w+)\\s+(.+)$/)\n  if (!match) return null\n\n  const id = match[1]\n  const styleStr = match[2]\n  const styles: Record<string, string> = {}\n\n  // Parse comma-separated style properties\n  const parts = styleStr.split(',')\n  for (const part of parts) {\n    const [key, value] = part.split(':').map(s => s.trim())\n    if (key && value) {\n      styles[key] = value\n    }\n  }\n\n  return { id, styles }\n}\n\nexport function parseFlowchart(source: string): Flowchart {\n  const lines = source.split('\\n').map(l => l.trim()).filter(l => l && !l.startsWith('%%'))\n\n  const flowchart: Flowchart = {\n    direction: 'TB',\n    nodes: new Map(),\n    edges: [],\n    subgraphs: [],\n  }\n\n  // Parse direction from first line\n  const firstLine = lines[0]\n  const dirMatch = firstLine?.match(/^flowchart\\s+(TB|BT|LR|RL)$/i)\n  if (dirMatch) {\n    flowchart.direction = dirMatch[1].toUpperCase() as Direction\n    lines.shift()\n  } else if (firstLine?.startsWith('flowchart')) {\n    flowchart.direction = 'TB'\n    lines.shift()\n  }\n\n  // Track subgraph parsing state\n  let currentSubgraph: FlowchartSubgraph | null = null\n  const subgraphStack: FlowchartSubgraph[] = []\n  const nodeToSubgraph = new Map<string, string>()\n\n  for (const line of lines) {\n    // Subgraph start\n    const subgraphMatch = line.match(/^subgraph\\s+(\\w+)(?:\\[\"([^\"]+)\"\\])?$/)\n    if (subgraphMatch) {\n      const subgraph: FlowchartSubgraph = {\n        id: subgraphMatch[1],\n        label: subgraphMatch[2] || subgraphMatch[1],\n        nodeIds: [],\n      }\n      if (currentSubgraph) {\n        subgraphStack.push(currentSubgraph)\n      }\n      currentSubgraph = subgraph\n      flowchart.subgraphs.push(subgraph)\n      continue\n    }\n\n    // Subgraph end\n    if (line === 'end') {\n      currentSubgraph = subgraphStack.pop() || null\n      continue\n    }\n\n    // Style directive\n    const styleResult = parseStyle(line)\n    if (styleResult) {\n      const subgraph = flowchart.subgraphs.find(s => s.id === styleResult.id)\n      if (subgraph) {\n        subgraph.style = styleResult.styles\n      }\n      continue\n    }\n\n    // Try to parse as edge\n    const edgeResult = parseEdge(line)\n    if (edgeResult) {\n      // Handle 'from' node: use inline definition if present, otherwise create placeholder if missing\n      if (edgeResult.fromNode) {\n        flowchart.nodes.set(edgeResult.fromNode.id, edgeResult.fromNode)\n      } else if (!flowchart.nodes.has(edgeResult.from)) {\n        flowchart.nodes.set(edgeResult.from, {\n          id: edgeResult.from,\n          label: edgeResult.from,\n          shape: 'rect',\n        })\n      }\n\n      // Handle 'to' node: use inline definition if present, otherwise create placeholder if missing\n      if (edgeResult.toNode) {\n        flowchart.nodes.set(edgeResult.toNode.id, edgeResult.toNode)\n      } else if (!flowchart.nodes.has(edgeResult.to)) {\n        flowchart.nodes.set(edgeResult.to, {\n          id: edgeResult.to,\n          label: edgeResult.to,\n          shape: 'rect',\n        })\n      }\n\n      // Track nodes in current subgraph\n      if (currentSubgraph) {\n        if (!nodeToSubgraph.has(edgeResult.from)) {\n          currentSubgraph.nodeIds.push(edgeResult.from)\n          nodeToSubgraph.set(edgeResult.from, currentSubgraph.id)\n        }\n        if (!nodeToSubgraph.has(edgeResult.to)) {\n          currentSubgraph.nodeIds.push(edgeResult.to)\n          nodeToSubgraph.set(edgeResult.to, currentSubgraph.id)\n        }\n      }\n\n      flowchart.edges.push({\n        from: edgeResult.from,\n        to: edgeResult.to,\n        label: edgeResult.label,\n        style: edgeResult.style,\n      })\n      continue\n    }\n\n    // Try to parse as standalone node definition\n    const nodeResult = parseNodeDefinition(line)\n    if (nodeResult) {\n      flowchart.nodes.set(nodeResult.id, {\n        id: nodeResult.id,\n        label: nodeResult.label,\n        shape: nodeResult.shape,\n      })\n\n      if (currentSubgraph && !nodeToSubgraph.has(nodeResult.id)) {\n        currentSubgraph.nodeIds.push(nodeResult.id)\n        nodeToSubgraph.set(nodeResult.id, currentSubgraph.id)\n      }\n    }\n  }\n\n  return flowchart\n}\n","import type { Flowchart, Direction, FlowchartSubgraph } from './parser'\n\nexport interface NodeLayout {\n  id: string\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport interface EdgeLayout {\n  from: string\n  to: string\n  label?: string\n  style: 'solid' | 'dashed'\n  points: Array<{ x: number; y: number }>\n}\n\nexport interface SubgraphLayout {\n  id: string\n  label: string\n  x: number\n  y: number\n  width: number\n  height: number\n  style?: Record<string, string>\n}\n\nexport interface FlowchartLayout {\n  width: number\n  height: number\n  nodes: NodeLayout[]\n  edges: EdgeLayout[]\n  subgraphs: SubgraphLayout[]\n}\n\nconst NODE_WIDTH = 150\nconst NODE_HEIGHT = 50\nconst NODE_PADDING = 30\nconst SUBGRAPH_PADDING = 40\nconst SUBGRAPH_HEADER = 30\n\ninterface NodeRank {\n  id: string\n  rank: number\n  order: number\n}\n\nfunction computeRanks(flowchart: Flowchart): Map<string, NodeRank> {\n  const ranks = new Map<string, NodeRank>()\n  const nodeIds = Array.from(flowchart.nodes.keys())\n\n  // Build adjacency list\n  const outgoing = new Map<string, string[]>()\n  const incoming = new Map<string, string[]>()\n\n  for (const id of nodeIds) {\n    outgoing.set(id, [])\n    incoming.set(id, [])\n  }\n\n  for (const edge of flowchart.edges) {\n    outgoing.get(edge.from)?.push(edge.to)\n    incoming.get(edge.to)?.push(edge.from)\n  }\n\n  // Find nodes with no incoming edges (roots)\n  const roots = nodeIds.filter(id => incoming.get(id)?.length === 0)\n  if (roots.length === 0 && nodeIds.length > 0) {\n    roots.push(nodeIds[0])\n  }\n\n  // BFS to assign ranks\n  const visited = new Set<string>()\n  const queue: Array<{ id: string; rank: number }> = roots.map(id => ({ id, rank: 0 }))\n\n  while (queue.length > 0) {\n    const { id, rank } = queue.shift()!\n\n    if (visited.has(id)) {\n      const existing = ranks.get(id)\n      if (existing && rank > existing.rank) {\n        existing.rank = rank\n      }\n      continue\n    }\n\n    visited.add(id)\n    ranks.set(id, { id, rank, order: 0 })\n\n    for (const next of outgoing.get(id) || []) {\n      queue.push({ id: next, rank: rank + 1 })\n    }\n  }\n\n  // Handle any disconnected nodes\n  for (const id of nodeIds) {\n    if (!ranks.has(id)) {\n      ranks.set(id, { id, rank: 0, order: 0 })\n    }\n  }\n\n  // Assign order within each rank\n  const rankGroups = new Map<number, string[]>()\n  for (const [id, info] of ranks) {\n    const group = rankGroups.get(info.rank) || []\n    group.push(id)\n    rankGroups.set(info.rank, group)\n  }\n\n  for (const [, group] of rankGroups) {\n    group.forEach((id, index) => {\n      const info = ranks.get(id)!\n      info.order = index\n    })\n  }\n\n  return ranks\n}\n\nfunction layoutSubgraph(\n  subgraph: FlowchartSubgraph,\n  nodeLayouts: Map<string, NodeLayout>,\n  direction: Direction\n): SubgraphLayout {\n  if (subgraph.nodeIds.length === 0) {\n    return {\n      id: subgraph.id,\n      label: subgraph.label,\n      x: 0,\n      y: 0,\n      width: NODE_WIDTH + SUBGRAPH_PADDING * 2,\n      height: NODE_HEIGHT + SUBGRAPH_PADDING * 2 + SUBGRAPH_HEADER,\n      style: subgraph.style,\n    }\n  }\n\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n\n  for (const nodeId of subgraph.nodeIds) {\n    const node = nodeLayouts.get(nodeId)\n    if (node) {\n      minX = Math.min(minX, node.x)\n      minY = Math.min(minY, node.y)\n      maxX = Math.max(maxX, node.x + node.width)\n      maxY = Math.max(maxY, node.y + node.height)\n    }\n  }\n\n  return {\n    id: subgraph.id,\n    label: subgraph.label,\n    x: minX - SUBGRAPH_PADDING,\n    y: minY - SUBGRAPH_PADDING - SUBGRAPH_HEADER,\n    width: maxX - minX + SUBGRAPH_PADDING * 2,\n    height: maxY - minY + SUBGRAPH_PADDING * 2 + SUBGRAPH_HEADER,\n    style: subgraph.style,\n  }\n}\n\nexport function layoutFlowchart(flowchart: Flowchart): FlowchartLayout {\n  const ranks = computeRanks(flowchart)\n  const nodeLayouts = new Map<string, NodeLayout>()\n  const direction = flowchart.direction\n\n  // Group nodes by subgraph for layout purposes\n  const subgraphNodeIds = new Set<string>()\n  for (const sg of flowchart.subgraphs) {\n    for (const id of sg.nodeIds) {\n      subgraphNodeIds.add(id)\n    }\n  }\n\n  // Count nodes per rank\n  const rankCounts = new Map<number, number>()\n  for (const info of ranks.values()) {\n    rankCounts.set(info.rank, (rankCounts.get(info.rank) || 0) + 1)\n  }\n\n  // Position nodes based on rank and order\n  const isVertical = direction === 'TB' || direction === 'BT'\n  const isReversed = direction === 'BT' || direction === 'RL'\n\n  for (const [id, info] of ranks) {\n    const node = flowchart.nodes.get(id)!\n    const rankCount = rankCounts.get(info.rank) || 1\n\n    let x: number, y: number\n    const rankSpacing = NODE_HEIGHT + NODE_PADDING * 2\n    const orderSpacing = NODE_WIDTH + NODE_PADDING\n\n    if (isVertical) {\n      x = info.order * orderSpacing + (NODE_PADDING / 2)\n      y = info.rank * rankSpacing + NODE_PADDING\n      if (isReversed) {\n        const maxRank = Math.max(...Array.from(ranks.values()).map(r => r.rank))\n        y = (maxRank - info.rank) * rankSpacing + NODE_PADDING\n      }\n    } else {\n      x = info.rank * (NODE_WIDTH + NODE_PADDING * 2) + NODE_PADDING\n      y = info.order * rankSpacing + NODE_PADDING\n      if (isReversed) {\n        const maxRank = Math.max(...Array.from(ranks.values()).map(r => r.rank))\n        x = (maxRank - info.rank) * (NODE_WIDTH + NODE_PADDING * 2) + NODE_PADDING\n      }\n    }\n\n    nodeLayouts.set(id, {\n      id,\n      x,\n      y,\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n    })\n  }\n\n  // Layout subgraphs and adjust node positions\n  const subgraphLayouts: SubgraphLayout[] = []\n\n  // Process subgraphs and offset their nodes\n  let subgraphOffsetY = 0\n  for (const subgraph of flowchart.subgraphs) {\n    // First compute subgraph bounds\n    const sgLayout = layoutSubgraph(subgraph, nodeLayouts, direction)\n\n    // Offset all nodes in this subgraph\n    const offsetY = subgraphOffsetY - sgLayout.y + NODE_PADDING\n    for (const nodeId of subgraph.nodeIds) {\n      const node = nodeLayouts.get(nodeId)\n      if (node) {\n        node.y += offsetY\n      }\n    }\n\n    // Recompute subgraph layout after offset\n    const finalLayout = layoutSubgraph(subgraph, nodeLayouts, direction)\n    subgraphLayouts.push(finalLayout)\n\n    subgraphOffsetY = finalLayout.y + finalLayout.height + NODE_PADDING\n  }\n\n  // Create edge layouts\n  const edgeLayouts: EdgeLayout[] = flowchart.edges.map(edge => {\n    const fromNode = nodeLayouts.get(edge.from)\n    const toNode = nodeLayouts.get(edge.to)\n\n    if (!fromNode || !toNode) {\n      return {\n        from: edge.from,\n        to: edge.to,\n        label: edge.label,\n        style: edge.style,\n        points: [],\n      }\n    }\n\n    // Simple direct connection\n    const fromCenter = {\n      x: fromNode.x + fromNode.width / 2,\n      y: fromNode.y + fromNode.height / 2,\n    }\n    const toCenter = {\n      x: toNode.x + toNode.width / 2,\n      y: toNode.y + toNode.height / 2,\n    }\n\n    // Determine connection points based on relative position\n    let startPoint: { x: number; y: number }\n    let endPoint: { x: number; y: number }\n\n    if (isVertical) {\n      if (fromCenter.y < toCenter.y) {\n        startPoint = { x: fromCenter.x, y: fromNode.y + fromNode.height }\n        endPoint = { x: toCenter.x, y: toNode.y }\n      } else {\n        startPoint = { x: fromCenter.x, y: fromNode.y }\n        endPoint = { x: toCenter.x, y: toNode.y + toNode.height }\n      }\n    } else {\n      if (fromCenter.x < toCenter.x) {\n        startPoint = { x: fromNode.x + fromNode.width, y: fromCenter.y }\n        endPoint = { x: toNode.x, y: toCenter.y }\n      } else {\n        startPoint = { x: fromNode.x, y: fromCenter.y }\n        endPoint = { x: toNode.x + toNode.width, y: toCenter.y }\n      }\n    }\n\n    return {\n      from: edge.from,\n      to: edge.to,\n      label: edge.label,\n      style: edge.style,\n      points: [startPoint, endPoint],\n    }\n  })\n\n  // Find minimum coordinates across all elements\n  let minX = Infinity, minY = Infinity\n  let maxX = -Infinity, maxY = -Infinity\n\n  for (const node of nodeLayouts.values()) {\n    minX = Math.min(minX, node.x)\n    minY = Math.min(minY, node.y)\n    maxX = Math.max(maxX, node.x + node.width)\n    maxY = Math.max(maxY, node.y + node.height)\n  }\n  for (const sg of subgraphLayouts) {\n    minX = Math.min(minX, sg.x)\n    minY = Math.min(minY, sg.y)\n    maxX = Math.max(maxX, sg.x + sg.width)\n    maxY = Math.max(maxY, sg.y + sg.height)\n  }\n\n  // Normalize: shift everything so minimum is at NODE_PADDING\n  const offsetX = NODE_PADDING - minX\n  const offsetY = NODE_PADDING - minY\n\n  for (const node of nodeLayouts.values()) {\n    node.x += offsetX\n    node.y += offsetY\n  }\n  for (const sg of subgraphLayouts) {\n    sg.x += offsetX\n    sg.y += offsetY\n  }\n  for (const edge of edgeLayouts) {\n    for (const point of edge.points) {\n      point.x += offsetX\n      point.y += offsetY\n    }\n  }\n\n  // Recompute dimensions after normalization\n  const width = maxX - minX + NODE_PADDING * 2\n  const height = maxY - minY + NODE_PADDING * 2\n\n  return {\n    width,\n    height,\n    nodes: Array.from(nodeLayouts.values()),\n    edges: edgeLayouts,\n    subgraphs: subgraphLayouts,\n  }\n}\n","import type { Flowchart, FlowchartNode } from './parser'\nimport type { FlowchartLayout, NodeLayout, EdgeLayout, SubgraphLayout } from './layout'\n\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n}\n\nfunction renderNodeShape(node: NodeLayout, flowchartNode: FlowchartNode): string {\n  const { x, y, width, height } = node\n  const rx = 4 // border radius\n\n  switch (flowchartNode.shape) {\n    case 'rounded':\n      return `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" rx=\"20\" ry=\"20\" class=\"flowchart-node\"/>`\n    case 'diamond':\n      const cx = x + width / 2\n      const cy = y + height / 2\n      const hw = width / 2\n      const hh = height / 2\n      return `<polygon points=\"${cx},${y} ${x + width},${cy} ${cx},${y + height} ${x},${cy}\" class=\"flowchart-node\"/>`\n    case 'circle':\n      const r = Math.min(width, height) / 2\n      return `<circle cx=\"${x + width / 2}\" cy=\"${y + height / 2}\" r=\"${r}\" class=\"flowchart-node\"/>`\n    case 'rect':\n    default:\n      return `<rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" rx=\"${rx}\" ry=\"${rx}\" class=\"flowchart-node\"/>`\n  }\n}\n\nfunction renderNodeLabel(node: NodeLayout, flowchartNode: FlowchartNode): string {\n  const { x, y, width, height } = node\n  const cx = x + width / 2\n  const cy = y + height / 2\n\n  // Handle <br/> tags for multiline\n  const lines = flowchartNode.label.split(/<br\\s*\\/?>/)\n\n  if (lines.length === 1) {\n    return `<text x=\"${cx}\" y=\"${cy}\" class=\"flowchart-node-label\" dominant-baseline=\"middle\" text-anchor=\"middle\">${escapeHtml(lines[0])}</text>`\n  }\n\n  // Multiline text\n  const lineHeight = 14\n  const startY = cy - ((lines.length - 1) * lineHeight) / 2\n\n  return lines.map((line, i) =>\n    `<text x=\"${cx}\" y=\"${startY + i * lineHeight}\" class=\"flowchart-node-label\" dominant-baseline=\"middle\" text-anchor=\"middle\">${escapeHtml(line)}</text>`\n  ).join('\\n')\n}\n\nfunction renderEdge(edge: EdgeLayout): string {\n  if (edge.points.length < 2) return ''\n\n  const [start, end] = edge.points\n  const dashArray = edge.style === 'dashed' ? 'stroke-dasharray=\"5,5\"' : ''\n\n  // Calculate angle for arrow\n  const dx = end.x - start.x\n  const dy = end.y - start.y\n  const angle = Math.atan2(dy, dx)\n\n  // Arrow head size\n  const arrowSize = 8\n\n  // Adjust end point to not overlap with arrow\n  const adjustedEnd = {\n    x: end.x - Math.cos(angle) * arrowSize,\n    y: end.y - Math.sin(angle) * arrowSize,\n  }\n\n  // Create path with slight curve for better aesthetics\n  const midX = (start.x + end.x) / 2\n  const midY = (start.y + end.y) / 2\n\n  let path: string\n  if (Math.abs(dx) > Math.abs(dy)) {\n    // Horizontal-ish: use vertical control points\n    path = `M ${start.x} ${start.y} C ${midX} ${start.y}, ${midX} ${end.y}, ${adjustedEnd.x} ${adjustedEnd.y}`\n  } else {\n    // Vertical-ish: use horizontal control points\n    path = `M ${start.x} ${start.y} C ${start.x} ${midY}, ${end.x} ${midY}, ${adjustedEnd.x} ${adjustedEnd.y}`\n  }\n\n  // Arrow head\n  const arrowPath = `\n    M ${end.x} ${end.y}\n    L ${end.x - arrowSize * Math.cos(angle - Math.PI / 6)} ${end.y - arrowSize * Math.sin(angle - Math.PI / 6)}\n    L ${end.x - arrowSize * Math.cos(angle + Math.PI / 6)} ${end.y - arrowSize * Math.sin(angle + Math.PI / 6)}\n    Z\n  `\n\n  let labelSvg = ''\n  if (edge.label) {\n    const labelX = midX\n    const labelY = midY - 8\n    labelSvg = `\n      <rect x=\"${labelX - edge.label.length * 4}\" y=\"${labelY - 10}\"\n            width=\"${edge.label.length * 8}\" height=\"16\"\n            class=\"flowchart-edge-label-bg\"/>\n      <text x=\"${labelX}\" y=\"${labelY}\" class=\"flowchart-edge-label\"\n            dominant-baseline=\"middle\" text-anchor=\"middle\">${escapeHtml(edge.label)}</text>\n    `\n  }\n\n  return `\n    <g class=\"flowchart-edge\">\n      <path d=\"${path}\" class=\"flowchart-edge-path\" ${dashArray}/>\n      <path d=\"${arrowPath}\" class=\"flowchart-edge-arrow\"/>\n      ${labelSvg}\n    </g>\n  `\n}\n\nfunction renderSubgraph(subgraph: SubgraphLayout): string {\n  const { x, y, width, height, label, style } = subgraph\n\n  let styleAttr = ''\n  if (style) {\n    const fill = style.fill || 'none'\n    const stroke = style.stroke || '#666'\n    styleAttr = `fill=\"${fill}\" stroke=\"${stroke}\"`\n  }\n\n  return `\n    <g class=\"flowchart-subgraph\">\n      <rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\"\n            class=\"flowchart-subgraph-rect\" rx=\"8\" ry=\"8\" ${styleAttr}/>\n      <text x=\"${x + 10}\" y=\"${y + 20}\" class=\"flowchart-subgraph-label\">${escapeHtml(label)}</text>\n    </g>\n  `\n}\n\nexport function renderFlowchartSvg(flowchart: Flowchart, layout: FlowchartLayout): string {\n  const { width, height, nodes, edges, subgraphs } = layout\n\n  const subgraphsSvg = subgraphs.map(sg => renderSubgraph(sg)).join('\\n')\n\n  const edgesSvg = edges.map(edge => renderEdge(edge)).join('\\n')\n\n  const nodesSvg = nodes.map(node => {\n    const flowchartNode = flowchart.nodes.get(node.id)!\n    return `\n      <g class=\"flowchart-node-group\" data-id=\"${node.id}\">\n        ${renderNodeShape(node, flowchartNode)}\n        ${renderNodeLabel(node, flowchartNode)}\n      </g>\n    `\n  }).join('\\n')\n\n  // Use CSS variables with defaults for standalone use\n  return `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\" class=\"flowchart-svg\">\n      <style>\n        .flowchart-svg {\n          font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif;\n          font-size: 12px;\n        }\n        .flowchart-node {\n          fill: var(--flowchart-node-fill, #fff);\n          stroke: var(--flowchart-node-stroke, #333);\n          stroke-width: 1.5;\n        }\n        .flowchart-node-label {\n          fill: var(--flowchart-node-label, #333);\n          font-size: 12px;\n        }\n        .flowchart-edge-path {\n          fill: none;\n          stroke: var(--flowchart-edge-stroke, #666);\n          stroke-width: 1.5;\n        }\n        .flowchart-edge-arrow {\n          fill: var(--flowchart-edge-arrow, #666);\n          stroke: none;\n        }\n        .flowchart-edge-label {\n          fill: var(--flowchart-edge-label, #666);\n          font-size: 11px;\n        }\n        .flowchart-edge-label-bg {\n          fill: var(--flowchart-edge-label-bg, #fff);\n          stroke: none;\n        }\n        .flowchart-subgraph-rect {\n          fill: var(--flowchart-subgraph-fill, #f5f5f5);\n          stroke: var(--flowchart-subgraph-stroke, #999);\n          stroke-width: 1;\n          stroke-dasharray: 5,5;\n        }\n        .flowchart-subgraph-label {\n          fill: var(--flowchart-subgraph-label, #666);\n          font-weight: 500;\n          font-size: 13px;\n        }\n      </style>\n      ${subgraphsSvg}\n      ${edgesSvg}\n      ${nodesSvg}\n    </svg>\n  `\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC6BA,SAAS,oBAAoB,MAAmF;AAE9G,QAAM,WAAoE;AAAA,IACxE,EAAE,OAAO,uBAAuB,OAAO,OAAO;AAAA;AAAA,IAC9C,EAAE,OAAO,mBAAmB,OAAO,OAAO;AAAA;AAAA,IAC1C,EAAE,OAAO,mBAAmB,OAAO,UAAU;AAAA;AAAA,IAC7C,EAAE,OAAO,uBAAuB,OAAO,SAAS;AAAA;AAAA,IAChD,EAAE,OAAO,mBAAmB,OAAO,UAAU;AAAA;AAAA,EAC/C;AAEA,aAAW,EAAE,OAAO,MAAM,KAAK,UAAU;AACvC,UAAM,QAAQ,KAAK,MAAM,KAAK;AAC9B,QAAI,OAAO;AACT,aAAO,EAAE,IAAI,MAAM,CAAC,GAAG,OAAO,MAAM,CAAC,GAAG,MAAM;AAAA,IAChD;AAAA,EACF;AAGA,QAAM,aAAa,KAAK,MAAM,SAAS;AACvC,MAAI,YAAY;AACd,WAAO,EAAE,IAAI,WAAW,CAAC,GAAG,OAAO,WAAW,CAAC,GAAG,OAAO,OAAO;AAAA,EAClE;AAEA,SAAO;AACT;AAYA,SAAS,UAAU,MAAsC;AAGvD,QAAM,eAAe;AAAA,IACnB;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,EACF;AAEA,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,UAAM,QAAQ,KAAK,MAAM,aAAa,CAAC,CAAC;AACxC,QAAI,OAAO;AACT,YAAM,WAAW,IAAI;AACrB,YAAM,QAA4B,MAAM,KAAK,MAAM,IAAI,WAAW;AAElE,UAAI,UAAkB,QAAgB;AAEtC,UAAI,UAAU;AACZ,mBAAW,MAAM,CAAC,EAAE,KAAK;AACzB,gBAAQ,MAAM,CAAC,EAAE,KAAK;AACtB,iBAAS,MAAM,CAAC,EAAE,KAAK;AAAA,MACzB,OAAO;AACL,mBAAW,MAAM,CAAC,EAAE,KAAK;AACzB,iBAAS,MAAM,CAAC,EAAE,KAAK;AAAA,MACzB;AAGA,YAAM,WAAW,oBAAoB,QAAQ;AAC7C,YAAM,SAAS,oBAAoB,MAAM;AAEzC,UAAI,YAAY,QAAQ;AACtB,cAAM,SAA0B;AAAA,UAC9B,MAAM,SAAS;AAAA,UACf,IAAI,OAAO;AAAA,UACX;AAAA,UACA;AAAA,QACF;AAGA,YAAI,SAAS,UAAU,SAAS,IAAI;AAClC,iBAAO,WAAW;AAAA,QACpB;AACA,YAAI,OAAO,UAAU,OAAO,IAAI;AAC9B,iBAAO,SAAS;AAAA,QAClB;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,WAAW,MAAqE;AACvF,QAAM,QAAQ,KAAK,MAAM,wBAAwB;AACjD,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,KAAK,MAAM,CAAC;AAClB,QAAM,WAAW,MAAM,CAAC;AACxB,QAAM,SAAiC,CAAC;AAGxC,QAAM,QAAQ,SAAS,MAAM,GAAG;AAChC,aAAW,QAAQ,OAAO;AACxB,UAAM,CAAC,KAAK,KAAK,IAAI,KAAK,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC;AACtD,QAAI,OAAO,OAAO;AAChB,aAAO,GAAG,IAAI;AAAA,IAChB;AAAA,EACF;AAEA,SAAO,EAAE,IAAI,OAAO;AACtB;AAEO,SAAS,eAAe,QAA2B;AACxD,QAAM,QAAQ,OAAO,MAAM,IAAI,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAK,KAAK,CAAC,EAAE,WAAW,IAAI,CAAC;AAExF,QAAM,YAAuB;AAAA,IAC3B,WAAW;AAAA,IACX,OAAO,oBAAI,IAAI;AAAA,IACf,OAAO,CAAC;AAAA,IACR,WAAW,CAAC;AAAA,EACd;AAGA,QAAM,YAAY,MAAM,CAAC;AACzB,QAAM,WAAW,WAAW,MAAM,8BAA8B;AAChE,MAAI,UAAU;AACZ,cAAU,YAAY,SAAS,CAAC,EAAE,YAAY;AAC9C,UAAM,MAAM;AAAA,EACd,WAAW,WAAW,WAAW,WAAW,GAAG;AAC7C,cAAU,YAAY;AACtB,UAAM,MAAM;AAAA,EACd;AAGA,MAAI,kBAA4C;AAChD,QAAM,gBAAqC,CAAC;AAC5C,QAAM,iBAAiB,oBAAI,IAAoB;AAE/C,aAAW,QAAQ,OAAO;AAExB,UAAM,gBAAgB,KAAK,MAAM,sCAAsC;AACvE,QAAI,eAAe;AACjB,YAAM,WAA8B;AAAA,QAClC,IAAI,cAAc,CAAC;AAAA,QACnB,OAAO,cAAc,CAAC,KAAK,cAAc,CAAC;AAAA,QAC1C,SAAS,CAAC;AAAA,MACZ;AACA,UAAI,iBAAiB;AACnB,sBAAc,KAAK,eAAe;AAAA,MACpC;AACA,wBAAkB;AAClB,gBAAU,UAAU,KAAK,QAAQ;AACjC;AAAA,IACF;AAGA,QAAI,SAAS,OAAO;AAClB,wBAAkB,cAAc,IAAI,KAAK;AACzC;AAAA,IACF;AAGA,UAAM,cAAc,WAAW,IAAI;AACnC,QAAI,aAAa;AACf,YAAM,WAAW,UAAU,UAAU,KAAK,OAAK,EAAE,OAAO,YAAY,EAAE;AACtE,UAAI,UAAU;AACZ,iBAAS,QAAQ,YAAY;AAAA,MAC/B;AACA;AAAA,IACF;AAGA,UAAM,aAAa,UAAU,IAAI;AACjC,QAAI,YAAY;AAEd,UAAI,WAAW,UAAU;AACvB,kBAAU,MAAM,IAAI,WAAW,SAAS,IAAI,WAAW,QAAQ;AAAA,MACjE,WAAW,CAAC,UAAU,MAAM,IAAI,WAAW,IAAI,GAAG;AAChD,kBAAU,MAAM,IAAI,WAAW,MAAM;AAAA,UACnC,IAAI,WAAW;AAAA,UACf,OAAO,WAAW;AAAA,UAClB,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAGA,UAAI,WAAW,QAAQ;AACrB,kBAAU,MAAM,IAAI,WAAW,OAAO,IAAI,WAAW,MAAM;AAAA,MAC7D,WAAW,CAAC,UAAU,MAAM,IAAI,WAAW,EAAE,GAAG;AAC9C,kBAAU,MAAM,IAAI,WAAW,IAAI;AAAA,UACjC,IAAI,WAAW;AAAA,UACf,OAAO,WAAW;AAAA,UAClB,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAGA,UAAI,iBAAiB;AACnB,YAAI,CAAC,eAAe,IAAI,WAAW,IAAI,GAAG;AACxC,0BAAgB,QAAQ,KAAK,WAAW,IAAI;AAC5C,yBAAe,IAAI,WAAW,MAAM,gBAAgB,EAAE;AAAA,QACxD;AACA,YAAI,CAAC,eAAe,IAAI,WAAW,EAAE,GAAG;AACtC,0BAAgB,QAAQ,KAAK,WAAW,EAAE;AAC1C,yBAAe,IAAI,WAAW,IAAI,gBAAgB,EAAE;AAAA,QACtD;AAAA,MACF;AAEA,gBAAU,MAAM,KAAK;AAAA,QACnB,MAAM,WAAW;AAAA,QACjB,IAAI,WAAW;AAAA,QACf,OAAO,WAAW;AAAA,QAClB,OAAO,WAAW;AAAA,MACpB,CAAC;AACD;AAAA,IACF;AAGA,UAAM,aAAa,oBAAoB,IAAI;AAC3C,QAAI,YAAY;AACd,gBAAU,MAAM,IAAI,WAAW,IAAI;AAAA,QACjC,IAAI,WAAW;AAAA,QACf,OAAO,WAAW;AAAA,QAClB,OAAO,WAAW;AAAA,MACpB,CAAC;AAED,UAAI,mBAAmB,CAAC,eAAe,IAAI,WAAW,EAAE,GAAG;AACzD,wBAAgB,QAAQ,KAAK,WAAW,EAAE;AAC1C,uBAAe,IAAI,WAAW,IAAI,gBAAgB,EAAE;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;AClOA,IAAM,aAAa;AACnB,IAAM,cAAc;AACpB,IAAM,eAAe;AACrB,IAAM,mBAAmB;AACzB,IAAM,kBAAkB;AAQxB,SAAS,aAAa,WAA6C;AACjE,QAAM,QAAQ,oBAAI,IAAsB;AACxC,QAAM,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,CAAC;AAGjD,QAAM,WAAW,oBAAI,IAAsB;AAC3C,QAAM,WAAW,oBAAI,IAAsB;AAE3C,aAAW,MAAM,SAAS;AACxB,aAAS,IAAI,IAAI,CAAC,CAAC;AACnB,aAAS,IAAI,IAAI,CAAC,CAAC;AAAA,EACrB;AAEA,aAAW,QAAQ,UAAU,OAAO;AAClC,aAAS,IAAI,KAAK,IAAI,GAAG,KAAK,KAAK,EAAE;AACrC,aAAS,IAAI,KAAK,EAAE,GAAG,KAAK,KAAK,IAAI;AAAA,EACvC;AAGA,QAAM,QAAQ,QAAQ,OAAO,QAAM,SAAS,IAAI,EAAE,GAAG,WAAW,CAAC;AACjE,MAAI,MAAM,WAAW,KAAK,QAAQ,SAAS,GAAG;AAC5C,UAAM,KAAK,QAAQ,CAAC,CAAC;AAAA,EACvB;AAGA,QAAM,UAAU,oBAAI,IAAY;AAChC,QAAM,QAA6C,MAAM,IAAI,SAAO,EAAE,IAAI,MAAM,EAAE,EAAE;AAEpF,SAAO,MAAM,SAAS,GAAG;AACvB,UAAM,EAAE,IAAI,KAAK,IAAI,MAAM,MAAM;AAEjC,QAAI,QAAQ,IAAI,EAAE,GAAG;AACnB,YAAM,WAAW,MAAM,IAAI,EAAE;AAC7B,UAAI,YAAY,OAAO,SAAS,MAAM;AACpC,iBAAS,OAAO;AAAA,MAClB;AACA;AAAA,IACF;AAEA,YAAQ,IAAI,EAAE;AACd,UAAM,IAAI,IAAI,EAAE,IAAI,MAAM,OAAO,EAAE,CAAC;AAEpC,eAAW,QAAQ,SAAS,IAAI,EAAE,KAAK,CAAC,GAAG;AACzC,YAAM,KAAK,EAAE,IAAI,MAAM,MAAM,OAAO,EAAE,CAAC;AAAA,IACzC;AAAA,EACF;AAGA,aAAW,MAAM,SAAS;AACxB,QAAI,CAAC,MAAM,IAAI,EAAE,GAAG;AAClB,YAAM,IAAI,IAAI,EAAE,IAAI,MAAM,GAAG,OAAO,EAAE,CAAC;AAAA,IACzC;AAAA,EACF;AAGA,QAAM,aAAa,oBAAI,IAAsB;AAC7C,aAAW,CAAC,IAAI,IAAI,KAAK,OAAO;AAC9B,UAAM,QAAQ,WAAW,IAAI,KAAK,IAAI,KAAK,CAAC;AAC5C,UAAM,KAAK,EAAE;AACb,eAAW,IAAI,KAAK,MAAM,KAAK;AAAA,EACjC;AAEA,aAAW,CAAC,EAAE,KAAK,KAAK,YAAY;AAClC,UAAM,QAAQ,CAAC,IAAI,UAAU;AAC3B,YAAM,OAAO,MAAM,IAAI,EAAE;AACzB,WAAK,QAAQ;AAAA,IACf,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,SAAS,eACP,UACA,aACA,WACgB;AAChB,MAAI,SAAS,QAAQ,WAAW,GAAG;AACjC,WAAO;AAAA,MACL,IAAI,SAAS;AAAA,MACb,OAAO,SAAS;AAAA,MAChB,GAAG;AAAA,MACH,GAAG;AAAA,MACH,OAAO,aAAa,mBAAmB;AAAA,MACvC,QAAQ,cAAc,mBAAmB,IAAI;AAAA,MAC7C,OAAO,SAAS;AAAA,IAClB;AAAA,EACF;AAEA,MAAI,OAAO,UAAU,OAAO,UAAU,OAAO,WAAW,OAAO;AAE/D,aAAW,UAAU,SAAS,SAAS;AACrC,UAAM,OAAO,YAAY,IAAI,MAAM;AACnC,QAAI,MAAM;AACR,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,aAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,aAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,KAAK;AACzC,aAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,MAAM;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AAAA,IACL,IAAI,SAAS;AAAA,IACb,OAAO,SAAS;AAAA,IAChB,GAAG,OAAO;AAAA,IACV,GAAG,OAAO,mBAAmB;AAAA,IAC7B,OAAO,OAAO,OAAO,mBAAmB;AAAA,IACxC,QAAQ,OAAO,OAAO,mBAAmB,IAAI;AAAA,IAC7C,OAAO,SAAS;AAAA,EAClB;AACF;AAEO,SAAS,gBAAgB,WAAuC;AACrE,QAAM,QAAQ,aAAa,SAAS;AACpC,QAAM,cAAc,oBAAI,IAAwB;AAChD,QAAM,YAAY,UAAU;AAG5B,QAAM,kBAAkB,oBAAI,IAAY;AACxC,aAAW,MAAM,UAAU,WAAW;AACpC,eAAW,MAAM,GAAG,SAAS;AAC3B,sBAAgB,IAAI,EAAE;AAAA,IACxB;AAAA,EACF;AAGA,QAAM,aAAa,oBAAI,IAAoB;AAC3C,aAAW,QAAQ,MAAM,OAAO,GAAG;AACjC,eAAW,IAAI,KAAK,OAAO,WAAW,IAAI,KAAK,IAAI,KAAK,KAAK,CAAC;AAAA,EAChE;AAGA,QAAM,aAAa,cAAc,QAAQ,cAAc;AACvD,QAAM,aAAa,cAAc,QAAQ,cAAc;AAEvD,aAAW,CAAC,IAAI,IAAI,KAAK,OAAO;AAC9B,UAAM,OAAO,UAAU,MAAM,IAAI,EAAE;AACnC,UAAM,YAAY,WAAW,IAAI,KAAK,IAAI,KAAK;AAE/C,QAAI,GAAW;AACf,UAAM,cAAc,cAAc,eAAe;AACjD,UAAM,eAAe,aAAa;AAElC,QAAI,YAAY;AACd,UAAI,KAAK,QAAQ,eAAgB,eAAe;AAChD,UAAI,KAAK,OAAO,cAAc;AAC9B,UAAI,YAAY;AACd,cAAM,UAAU,KAAK,IAAI,GAAG,MAAM,KAAK,MAAM,OAAO,CAAC,EAAE,IAAI,OAAK,EAAE,IAAI,CAAC;AACvE,aAAK,UAAU,KAAK,QAAQ,cAAc;AAAA,MAC5C;AAAA,IACF,OAAO;AACL,UAAI,KAAK,QAAQ,aAAa,eAAe,KAAK;AAClD,UAAI,KAAK,QAAQ,cAAc;AAC/B,UAAI,YAAY;AACd,cAAM,UAAU,KAAK,IAAI,GAAG,MAAM,KAAK,MAAM,OAAO,CAAC,EAAE,IAAI,OAAK,EAAE,IAAI,CAAC;AACvE,aAAK,UAAU,KAAK,SAAS,aAAa,eAAe,KAAK;AAAA,MAChE;AAAA,IACF;AAEA,gBAAY,IAAI,IAAI;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAGA,QAAM,kBAAoC,CAAC;AAG3C,MAAI,kBAAkB;AACtB,aAAW,YAAY,UAAU,WAAW;AAE1C,UAAM,WAAW,eAAe,UAAU,aAAa,SAAS;AAGhE,UAAMA,WAAU,kBAAkB,SAAS,IAAI;AAC/C,eAAW,UAAU,SAAS,SAAS;AACrC,YAAM,OAAO,YAAY,IAAI,MAAM;AACnC,UAAI,MAAM;AACR,aAAK,KAAKA;AAAA,MACZ;AAAA,IACF;AAGA,UAAM,cAAc,eAAe,UAAU,aAAa,SAAS;AACnE,oBAAgB,KAAK,WAAW;AAEhC,sBAAkB,YAAY,IAAI,YAAY,SAAS;AAAA,EACzD;AAGA,QAAM,cAA4B,UAAU,MAAM,IAAI,UAAQ;AAC5D,UAAM,WAAW,YAAY,IAAI,KAAK,IAAI;AAC1C,UAAM,SAAS,YAAY,IAAI,KAAK,EAAE;AAEtC,QAAI,CAAC,YAAY,CAAC,QAAQ;AACxB,aAAO;AAAA,QACL,MAAM,KAAK;AAAA,QACX,IAAI,KAAK;AAAA,QACT,OAAO,KAAK;AAAA,QACZ,OAAO,KAAK;AAAA,QACZ,QAAQ,CAAC;AAAA,MACX;AAAA,IACF;AAGA,UAAM,aAAa;AAAA,MACjB,GAAG,SAAS,IAAI,SAAS,QAAQ;AAAA,MACjC,GAAG,SAAS,IAAI,SAAS,SAAS;AAAA,IACpC;AACA,UAAM,WAAW;AAAA,MACf,GAAG,OAAO,IAAI,OAAO,QAAQ;AAAA,MAC7B,GAAG,OAAO,IAAI,OAAO,SAAS;AAAA,IAChC;AAGA,QAAI;AACJ,QAAI;AAEJ,QAAI,YAAY;AACd,UAAI,WAAW,IAAI,SAAS,GAAG;AAC7B,qBAAa,EAAE,GAAG,WAAW,GAAG,GAAG,SAAS,IAAI,SAAS,OAAO;AAChE,mBAAW,EAAE,GAAG,SAAS,GAAG,GAAG,OAAO,EAAE;AAAA,MAC1C,OAAO;AACL,qBAAa,EAAE,GAAG,WAAW,GAAG,GAAG,SAAS,EAAE;AAC9C,mBAAW,EAAE,GAAG,SAAS,GAAG,GAAG,OAAO,IAAI,OAAO,OAAO;AAAA,MAC1D;AAAA,IACF,OAAO;AACL,UAAI,WAAW,IAAI,SAAS,GAAG;AAC7B,qBAAa,EAAE,GAAG,SAAS,IAAI,SAAS,OAAO,GAAG,WAAW,EAAE;AAC/D,mBAAW,EAAE,GAAG,OAAO,GAAG,GAAG,SAAS,EAAE;AAAA,MAC1C,OAAO;AACL,qBAAa,EAAE,GAAG,SAAS,GAAG,GAAG,WAAW,EAAE;AAC9C,mBAAW,EAAE,GAAG,OAAO,IAAI,OAAO,OAAO,GAAG,SAAS,EAAE;AAAA,MACzD;AAAA,IACF;AAEA,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,IAAI,KAAK;AAAA,MACT,OAAO,KAAK;AAAA,MACZ,OAAO,KAAK;AAAA,MACZ,QAAQ,CAAC,YAAY,QAAQ;AAAA,IAC/B;AAAA,EACF,CAAC;AAGD,MAAI,OAAO,UAAU,OAAO;AAC5B,MAAI,OAAO,WAAW,OAAO;AAE7B,aAAW,QAAQ,YAAY,OAAO,GAAG;AACvC,WAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,WAAO,KAAK,IAAI,MAAM,KAAK,CAAC;AAC5B,WAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,KAAK;AACzC,WAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,MAAM;AAAA,EAC5C;AACA,aAAW,MAAM,iBAAiB;AAChC,WAAO,KAAK,IAAI,MAAM,GAAG,CAAC;AAC1B,WAAO,KAAK,IAAI,MAAM,GAAG,CAAC;AAC1B,WAAO,KAAK,IAAI,MAAM,GAAG,IAAI,GAAG,KAAK;AACrC,WAAO,KAAK,IAAI,MAAM,GAAG,IAAI,GAAG,MAAM;AAAA,EACxC;AAGA,QAAM,UAAU,eAAe;AAC/B,QAAM,UAAU,eAAe;AAE/B,aAAW,QAAQ,YAAY,OAAO,GAAG;AACvC,SAAK,KAAK;AACV,SAAK,KAAK;AAAA,EACZ;AACA,aAAW,MAAM,iBAAiB;AAChC,OAAG,KAAK;AACR,OAAG,KAAK;AAAA,EACV;AACA,aAAW,QAAQ,aAAa;AAC9B,eAAW,SAAS,KAAK,QAAQ;AAC/B,YAAM,KAAK;AACX,YAAM,KAAK;AAAA,IACb;AAAA,EACF;AAGA,QAAM,QAAQ,OAAO,OAAO,eAAe;AAC3C,QAAM,SAAS,OAAO,OAAO,eAAe;AAE5C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO,MAAM,KAAK,YAAY,OAAO,CAAC;AAAA,IACtC,OAAO;AAAA,IACP,WAAW;AAAA,EACb;AACF;;;ACrVA,SAAS,WAAW,MAAsB;AACxC,SAAO,KACJ,QAAQ,MAAM,OAAO,EACrB,QAAQ,MAAM,MAAM,EACpB,QAAQ,MAAM,MAAM,EACpB,QAAQ,MAAM,QAAQ;AAC3B;AAEA,SAAS,gBAAgB,MAAkB,eAAsC;AAC/E,QAAM,EAAE,GAAG,GAAG,OAAO,OAAO,IAAI;AAChC,QAAM,KAAK;AAEX,UAAQ,cAAc,OAAO;AAAA,IAC3B,KAAK;AACH,aAAO,YAAY,CAAC,QAAQ,CAAC,YAAY,KAAK,aAAa,MAAM;AAAA,IACnE,KAAK;AACH,YAAM,KAAK,IAAI,QAAQ;AACvB,YAAM,KAAK,IAAI,SAAS;AACxB,YAAM,KAAK,QAAQ;AACnB,YAAM,KAAK,SAAS;AACpB,aAAO,oBAAoB,EAAE,IAAI,CAAC,IAAI,IAAI,KAAK,IAAI,EAAE,IAAI,EAAE,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,EAAE;AAAA,IACtF,KAAK;AACH,YAAM,IAAI,KAAK,IAAI,OAAO,MAAM,IAAI;AACpC,aAAO,eAAe,IAAI,QAAQ,CAAC,SAAS,IAAI,SAAS,CAAC,QAAQ,CAAC;AAAA,IACrE,KAAK;AAAA,IACL;AACE,aAAO,YAAY,CAAC,QAAQ,CAAC,YAAY,KAAK,aAAa,MAAM,SAAS,EAAE,SAAS,EAAE;AAAA,EAC3F;AACF;AAEA,SAAS,gBAAgB,MAAkB,eAAsC;AAC/E,QAAM,EAAE,GAAG,GAAG,OAAO,OAAO,IAAI;AAChC,QAAM,KAAK,IAAI,QAAQ;AACvB,QAAM,KAAK,IAAI,SAAS;AAGxB,QAAM,QAAQ,cAAc,MAAM,MAAM,YAAY;AAEpD,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,YAAY,EAAE,QAAQ,EAAE,kFAAkF,WAAW,MAAM,CAAC,CAAC,CAAC;AAAA,EACvI;AAGA,QAAM,aAAa;AACnB,QAAM,SAAS,MAAO,MAAM,SAAS,KAAK,aAAc;AAExD,SAAO,MAAM;AAAA,IAAI,CAAC,MAAM,MACtB,YAAY,EAAE,QAAQ,SAAS,IAAI,UAAU,kFAAkF,WAAW,IAAI,CAAC;AAAA,EACjJ,EAAE,KAAK,IAAI;AACb;AAEA,SAAS,WAAW,MAA0B;AAC5C,MAAI,KAAK,OAAO,SAAS,EAAG,QAAO;AAEnC,QAAM,CAAC,OAAO,GAAG,IAAI,KAAK;AAC1B,QAAM,YAAY,KAAK,UAAU,WAAW,2BAA2B;AAGvE,QAAM,KAAK,IAAI,IAAI,MAAM;AACzB,QAAM,KAAK,IAAI,IAAI,MAAM;AACzB,QAAM,QAAQ,KAAK,MAAM,IAAI,EAAE;AAG/B,QAAM,YAAY;AAGlB,QAAM,cAAc;AAAA,IAClB,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,IAC7B,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,EAC/B;AAGA,QAAM,QAAQ,MAAM,IAAI,IAAI,KAAK;AACjC,QAAM,QAAQ,MAAM,IAAI,IAAI,KAAK;AAEjC,MAAI;AACJ,MAAI,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,GAAG;AAE/B,WAAO,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,IAAI,IAAI,MAAM,CAAC,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,YAAY,CAAC,IAAI,YAAY,CAAC;AAAA,EAC1G,OAAO;AAEL,WAAO,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,MAAM,CAAC,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,IAAI,KAAK,YAAY,CAAC,IAAI,YAAY,CAAC;AAAA,EAC1G;AAGA,QAAM,YAAY;AAAA,QACZ,IAAI,CAAC,IAAI,IAAI,CAAC;AAAA,QACd,IAAI,IAAI,YAAY,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,CAAC,IAAI,IAAI,IAAI,YAAY,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,CAAC;AAAA,QACtG,IAAI,IAAI,YAAY,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,CAAC,IAAI,IAAI,IAAI,YAAY,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,CAAC;AAAA;AAAA;AAI5G,MAAI,WAAW;AACf,MAAI,KAAK,OAAO;AACd,UAAM,SAAS;AACf,UAAM,SAAS,OAAO;AACtB,eAAW;AAAA,iBACE,SAAS,KAAK,MAAM,SAAS,CAAC,QAAQ,SAAS,EAAE;AAAA,qBAC7C,KAAK,MAAM,SAAS,CAAC;AAAA;AAAA,iBAEzB,MAAM,QAAQ,MAAM;AAAA,8DACyB,WAAW,KAAK,KAAK,CAAC;AAAA;AAAA,EAElF;AAEA,SAAO;AAAA;AAAA,iBAEQ,IAAI,iCAAiC,SAAS;AAAA,iBAC9C,SAAS;AAAA,QAClB,QAAQ;AAAA;AAAA;AAGhB;AAEA,SAAS,eAAe,UAAkC;AACxD,QAAM,EAAE,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,IAAI;AAE9C,MAAI,YAAY;AAChB,MAAI,OAAO;AACT,UAAM,OAAO,MAAM,QAAQ;AAC3B,UAAM,SAAS,MAAM,UAAU;AAC/B,gBAAY,SAAS,IAAI,aAAa,MAAM;AAAA,EAC9C;AAEA,SAAO;AAAA;AAAA,iBAEQ,CAAC,QAAQ,CAAC,YAAY,KAAK,aAAa,MAAM;AAAA,4DACH,SAAS;AAAA,iBACpD,IAAI,EAAE,QAAQ,IAAI,EAAE,sCAAsC,WAAW,KAAK,CAAC;AAAA;AAAA;AAG5F;AAEO,SAAS,mBAAmB,WAAsB,QAAiC;AACxF,QAAM,EAAE,OAAO,QAAQ,OAAO,OAAO,UAAU,IAAI;AAEnD,QAAM,eAAe,UAAU,IAAI,QAAM,eAAe,EAAE,CAAC,EAAE,KAAK,IAAI;AAEtE,QAAM,WAAW,MAAM,IAAI,UAAQ,WAAW,IAAI,CAAC,EAAE,KAAK,IAAI;AAE9D,QAAM,WAAW,MAAM,IAAI,UAAQ;AACjC,UAAM,gBAAgB,UAAU,MAAM,IAAI,KAAK,EAAE;AACjD,WAAO;AAAA,iDACsC,KAAK,EAAE;AAAA,UAC9C,gBAAgB,MAAM,aAAa,CAAC;AAAA,UACpC,gBAAgB,MAAM,aAAa,CAAC;AAAA;AAAA;AAAA,EAG5C,CAAC,EAAE,KAAK,IAAI;AAGZ,SAAO;AAAA,2DACkD,KAAK,IAAI,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QA4ClE,YAAY;AAAA,QACZ,QAAQ;AAAA,QACR,QAAQ;AAAA;AAAA;AAGhB;;;AHhLO,SAAS,gBAAgB,QAAwB;AACtD,QAAM,YAAY,eAAe,MAAM;AACvC,QAAM,SAAS,gBAAgB,SAAS;AACxC,SAAO,mBAAmB,WAAW,MAAM;AAC7C;","names":["offsetY"]}